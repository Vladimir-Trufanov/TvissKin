### Проекты Интернета вещей с Arduino Nano 33 BLE Sense - Агус Курниаван

Знакомство с книгой Агуса Курниавана "Проекты Интернета вещей с Arduino Nano 33 BLE Sense" и программирование примеров из неё. 

![Распиновка платы Arduino Nano 33 BLE Sense](raspinovka-platy-arduino-nano-33-ble-sense.jpg)

Расположение выводов Arduino Nano 33 BLE Sense отображается на задней стороне платы. Пины цифрового ввода / вывода определяются как Dx, где x - цифровое число; например, D1 - это цифровой ввод / вывод на выводе 1.

### Проекты
#### [ButtonLed -  цифровой ввод-вывод](#buttonled)
#### [ClearEEPROM - очистка энергонезависимой памяти контроллера](#cleareeprom)
#### [MemoryGuide - руководство по памяти Arduino](MemoryGuide/MemoryGuide.md) 

---

#### ButtonLed
#### Цифровой ввод-вывод

Чтобы реализовать демонстрацию цифрового ввода-вывода на Arduino Nano 33 BLE Sense, нам понадобится светодиод и кнопка. Для этих примеров используйте внутренний светодиод (встроенный светодиод) на цифровом контакте 13. Нам также понадобится кнопка, подключенная к цифровому контакту 7. 

![](raspinovka2.jpg)

![Конфигурация соединений для проекта кнопки](ButtonLed/konfiguraciya-soedinenij-dlya-proekta-knopki.jpg)

![Включение лампочки на Arduino Uno](ButtonLed/vklyuchenie-lampochki-na-arduino-uno.jpg)

###### [к списку проектов](#%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D1%8B)

---

#### ClearEEPROM
#### Очистка энергонезависимой памяти контроллера

EEPROM (англ. Electrically Erasable Programmable Read-Only Memory) — электрически стираемое перепрограммируемое ПЗУ.

В общем, после нескольких загрузок при очередной загрузке скетча (Arduino 1.8.18) вышло сообщение, что места маловато и могут быть сбои при работе программы (Arduino 2.2.1 такого сообщения не выдавало), решил занятся вопросом.

***[Как сбросить память Arduino - https://citavers.ru/2023/10/25/kak-sbrosit-pamyat-arduino](https://citavers.ru/2023/10/25/kak-sbrosit-pamyat-arduino)***

Для различных моделей Arduino могут быть разные объёмы памяти и разные методы очистки памяти. В этой статье мы сосредоточимся на общих методах, которые будут полезны для большинства моделей Arduino.

Существует несколько способов очистки памяти на Arduino:

1. Очистка переменных.	Путем присвоения переменным новых значений или применения функции memset() можно очистить содержимое переменных и освободить занимаемую ими память.

2. Очистка массивов.	Для очистки массивов следует применить цикл и установить все элементы массива в значение по умолчанию или пустой символ.

3. Очистка объектов.	Путем вызова деструктора объекта или освобождения ресурсов, связанных с объектом, можно очистить память, занимаемую объектом.

4. Очистка сборщиком мусора. 	Arduino имеет встроенный сборщик мусора, который автоматически очищает память от неиспользуемых объектов. Однако иногда может потребоваться вызвать сборщик мусора вручную для более эффективной очистки памяти.

Регулярная очистка памяти позволяет оптимизировать использование ресурсов Arduino и создавать более надежные и эффективные проекты.

Полная заполненность памяти на Arduino может привести к физическим повреждениям памяти, таким как неправильная запись или чтение данных. В итоге, устройство может перестать работать или испытывать серьезные ошибки в выполнении программ.

```
Шаги по очистке памяти на Arduino

Шаг 1: Подключите Arduino к компьютеру с помощью USB-кабеля и запустите Arduino IDE.

Шаг 2: Откройте скетч, который вы хотите загрузить на Arduino.

Шаг 3: Нажмите на кнопку «Загрузить» в верхней части окна Arduino IDE.

Шаг 4: После того, как скетч загрузится на Arduino, нажмите на кнопку «Серийный монитор» в верхней части окна Arduino IDE.

Шаг 5: В окне серийного монитора нажмите на кнопку «Отправка переноса строки» внизу окна.

Шаг 6: Введите команду «AT+EEPROMERASE» в поле ввода команд и нажмите на кнопку «Отправить».

Шаг 7: Подождите несколько секунд, пока процесс очистки EEPROM-памяти Arduino завершится.

Шаг 8: При успешной очистке памяти, вы увидите сообщение «EEPROM has been erased» в окне серийного монитора.

Шаг 9: Теперь вы можете загрузить новый скетч на Arduino, и память будет полностью очищена.
```

***Обратите внимание, что очистка памяти EEPROM на Arduino удаляет все данные, хранящиеся в памяти. Поэтому перед выполнением этой операции убедитесь, что у вас есть резервные копии всех важных данных.***

```
Дополнительные советы по очистке памяти

1. Используйте флаги и флаговые биты: Вместо использования целых переменных для хранения логических значений, можно использовать битовые флаги, которые занимают намного меньше памяти. Например, вместо хранения состояния ON/OFF в отдельной переменной можно использовать только один бит.

2. Оптимизируйте использование массивов: Если вам необходимо хранить большое количество данных, попробуйте оптимизировать использование массивов. Например, вместо использования массива типа int можно использовать массив типа byte, если ваши значения не превышают диапазон от 0 до 255.

3. Освобождайте динамическую память: Если вы используете динамическую память с помощью функций malloc() и free(), убедитесь, что вы освобождаете все выделенные ресурсы после их использования. Это поможет избежать утечки памяти.

4. Оптимизируйте использование библиотек: Если вы используете сторонние библиотеки, проверьте, нет ли в них избыточных или неиспользуемых функций. Удалите неиспользуемые части библиотеки, чтобы уменьшить занимаемое ею место в памяти.

5. Удалите отладочный код: Если вы закончили разработку и отладку программы, удалите все отладочные выражения, которые могут занимать дополнительное место в памяти. Оставьте только необходимый код для работы вашей программы.

Следование этим советам поможет вам оптимизировать использование памяти на Arduino и сделать вашу программу более эффективной.
```

После проведения процедуры очистки памяти на устройстве Arduino, рекомендуется проверить эффективность выполненных действий. Это позволит убедиться, что ненужные данные и фрагменты кода были успешно удалены, и память устройства теперь используется оптимально.

Для проверки эффективности очистки памяти можно воспользоваться кодом ***[ClearEEPROM](ClearEEPROM/ClearEEPROM.ino)***, основанным на функциях, измеряющих объем свободной памяти до и после процедуры очистки.

###### [к списку проектов](#%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D1%8B)

#### MemoryGuide
#### Руководство по памяти Arduino

В дополнение к очистке памяти следует разобраться с [памятью Arduino](https://docs.arduino.cc/learn/programming/memory-guide). 

Каждый микроконтроллер (также известный как MCU) представляет собой интегральную схему (IC), обычно используемую для выполнения цифровых приложений или задач. Одной из важных частей микроконтроллера является его память; память временно или постоянно хранит информацию в микроконтроллерах.

 Блоки памяти - это полупроводниковые устройства, которые хранят и извлекают  данные; центральный процессор микроконтроллера (CPU) использует и обрабатывает данные, хранящиеся в блоках памяти. Блоки памяти в микроконтроллерах обычно описываются как массивы. Массивы памяти разделены на ячейки, в которых могут храниться данные, и доступ к ним осуществляется с использованием уникального идентификатора, представляющего их адрес (местоположение в памяти). Информация в ячейках памяти хранится с использованием двоичных цифр (битов), обычно организованных в байты (8 бит); она также может быть извлечена позже MCU или другими компонентами системы на базе микроконтроллера.

Память в вычислительных системах может быть энергозависимой или энергонезависимой. Энергозависимая память - это временная память, это означает, что данные хранятся во время работы системы, но они теряются навсегда, когда система выключается. Энергонезависимая память - это постоянная память; данные не теряются, даже если система выключена.

Существуют две компьютерных архитектуры, то есть две системы организации компонентов внутри вычислительной системы: фон Неймана и Гарварда. 

Архитектура фон Неймана хранит программные данные и инструкции в одном блоке памяти. Доступ к ним осуществляется центральным процессором с использованием одной и той же коммуникационной шины. Архитектура фон Неймана является фундаментальной, поскольку почти все цифровые компьютеры были спроектированы на основе этой архитектуры.

![Архитектура фон Неймана](MemoryGuide/Von-Neumann-architecture.png)

Архитектура Гарварда использует два отдельных блока памяти, один для хранения программных инструкций, а другой для хранения программных данных. Доступ к обоим блокам памяти в архитектуре Гарварда осуществляется центральным процессором по разным коммуникационным шинам.

![Архитектура Гарварда](MemoryGuide/Harvard-architecture.png)

Платы Arduino в основном основаны на двух семействах микроконтроллеров: AVR и ARM. В то время как микроконтроллеры семейства AVR® основаны на архитектурной модели Harvard, микроконтроллеры семейства ARM® могут быть основаны либо на моделях архитектуры von Neuman, либо Harvard architectures. 

```
Плата          Микроконтроллер	Семья	      Архитектура

UNO 	           ATmega328P	AVR	          Гарвард
Leonardo	       ATmega32U4	AVR	          Гарвард
Mega 2560 Rev3     ATmega2560	AVR           Гарвард
Micro	           ATmega32U4	AVR           Гарвард
MKR FOX 1200       ATSAMD21G18	ARM Cortex M0 Von Neumann
Nano	           ATmega328P	AVR           Гарвард
Nano 33 BLE Sense  nRF52840	    ARM Cortex M4 Гарвард
```
Все различные блоки памяти внутри микроконтроллера можно разделить на два основных типа: ОЗУ и ПЗУ. Оперативная память (ОЗУ) в системах на базе микроконтроллеров - это энергозависимая память, используемая для хранения временных данных, таких как переменные встроенного ПО системы. ПЗУ (постоянная память) в системах на базе микроконтроллеров - это энергонезависимая память, используемая для хранения постоянных данных, таких как прошивка системы.

Оперативная память и ПЗУ в системах на базе микроконтроллеров подразделяются на три основные категории: **[Flash, ОЗУ, EEPROM]()**.

Флэш память в системах на базе микроконтроллеров является частью ПЗУ - это место, где хранится прошивка системы для выполнения. Например, Blink.ino: когда мы компилируем этот эскиз, мы создаем двоичный файл, который позже сохраняется во флэш-памяти платы Arduino. Затем эскиз выполняется при включении платы.

EEPROM - в системах на базе микроконтроллеров стираемая программируемая постоянная память, или EEPROM, также является частью ПЗУ; фактически, флэш-память является разновидностью EEPROM. Основное различие между флэш-памятью и EEPROM заключается в том, как ими управляют; EEPROM может управляться на уровне байтов (запись или стирание), в то время как Flash может управляться на уровне блоков.

Оперативная память (RAM) в системах на базе микроконтроллеров - это место, где хранятся временные данные системы или данные во время выполнения; например, переменные, созданные функциями программы. Оперативной памятью в микроконтроллерах обычно является SRAM; это тип оперативной памяти, который использует триггер для хранения одного бита данных. Существует также другой тип оперативной памяти, который можно найти в микроконтроллерах: DRAM.

Распределение памяти плат Arduino:

![ Гарвардская архитектура AVR](MemoryGuide/karta-pamyati-avr.png)

SRAM плат Arduino на основе [AVR]() организована по разным разделам: Text, Data, BSS, Stack, Heap.

[text]() раздел содержит инструкции, загруженные во флэш-память; [data]() раздел содержит переменные, инициализированные в скетче, [BSS]() раздел содержит неинициализированные данные, в [stack]() разделе хранятся данные о функциях и прерываниях, а в [heap]() разделе хранятся переменные, созданные во время выполнения.

В гибридных архитектурах [ARM]() реализована так называемая карта памяти с различной конфигурацией карты адресов - 32-разрядной, 36-разрядной и 40-разрядной, которая зависит от требований адресного пространства "Системы на кристалле" (SoC) с дополнительным DRAM. Карта памяти обеспечивает интерфейс с дизайном SoC, сохраняя при этом большую часть системного контроля за счет высокоуровневого кодирования. Инструкции доступа к памяти могут использоваться в высокоуровневом коде для управления модулями прерывания и встроенными периферийными устройствами. Все это контролируется [блоком управления памятью]() (MMU).

Основная роль MMU заключается в том, чтобы позволить процессору выполнять множество задач независимо в своем собственном пространстве виртуальной памяти; затем MMU использует таблицы преобразования для установления моста между адресами виртуальной и физической памяти. Виртуальным адресом управляют с помощью программного обеспечения с инструкциями по памяти, а физический адрес - это система памяти, которая управляется в зависимости от входных данных таблицы преобразования, задаваемых виртуальным адресом.

![Организация памяти в микроконтроллерах на базе ARM, виртуально и физически](MemoryGuide/organizaciya-pamyati-v-mikrokontrollerah-na-baze-arm.png)

Память микроконтроллера на базе ARM разделена на следующие разделы:

виртуальный адрес - Kernel code and data (код ядра и данные), Application code and data;

физический адрес - ROM, RAM, Flash, Peripherals.


Данные о распределении памяти конкретной платы Arduino®:
```
Плата	         Flash    SRAM	EEPROM
UNO Mini         32 КБ	  2 КБ	  1 КБ
UNO Rev3         32 КБ	  2 КБ	  1 КБ
UNO WiFi Rev2	 48 КБ	  6 КБ	 256 B
Leonardo         32 КБ  2.5 KБ	  1 КБ
Mega            256 КБ    8 КБ	  4 КБ
Micro            32 КБ  2.5 KБ	  1 КБ
Ноль            256 КБ	 32 КБ       -
Nano             32 КБ	  2 КБ	  1 КБ
Nano 33 BLE Sense 1 МБ	256 КБ	     -
```
Аппаратная SDRAM и флэш-память Pro легко настраиваются по объему.

[Измерение использования памяти в платах Arduino.]()

Статистика использования памяти помогает понять, как управление ресурсами зависит от разработанной структуры кода. Потребность в загрузке памяти - это статистика, которая даст вам представление о том, насколько эффективен разработанный код. Это важный элемент при разработке, поскольку ресурсы внутри системы на базе микроконтроллера ограничены; программное обеспечение всегда должно работать без достижения максимальной грузоподъемности, чтобы избежать проблем. Загрузка памяти может наблюдаться либо в виде доступной оперативной памяти, имеющейся в распоряжении для конкретных задач, либо в виде оставшейся емкости флэш-памяти для требуемого запаса.
```
Чтобы избежать проблем во время выполнения, системы на базе микроконтроллеров всегда должны работать без достижения максимального объема памяти.
```
Флэш-память на платах Arduino измеряется уже с помощью Arduino IDE. Так как код приложения хранится во флэш-памяти,  то Arduino IDE сообщает об использовании флэш-памяти через консоль вывода компилятора.

Только выходные данные компилятора меняются в зависимости от того, основана ли плата на AVR или ARM.

[Измерение памяти SRAM]().

Иногда возникают ситуации, когда даже когда код успешно скомпилирован и загружен IDE на плату, он страдает от внезапных остановов. Эти проблемы, вероятно, связаны с перегрузкой ресурсов памяти или недостаточным объемом выделяемой памяти. Для решения этой проблемы необходимо понимать, в каком секторе кода потребность в памяти превышает доступные ресурсы. Следующий пример кода можно использовать для измерения использования SRAM в платах Arduino на основе [AVR]():

```
void display_freeram() 
{
  Serial.print(F("- SRAM left: "));
  Serial.println(freeRam());
}

int freeRam() 
{
  extern int __heap_start,*__brkval;
  int v;
  return (int)&v - (__brkval == 0  
    ? (int)&__heap_start : (int) __brkval);  
}
```









```
#include <EEPROM.h>

void setup() { }

void loop 
{
  // Write data into an specific address of the EEPROM memory 
  EEPROM.write(address, value);

  // Read data of an specific address of the EEPROM memory 
  EEPROM.read(address);
}
```



###### [к списку проектов](#%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D1%8B)
